![image](https://github.com/user-attachments/assets/37819309-4481-42cf-b878-3f522fbc3072)
![image](https://github.com/user-attachments/assets/73a1f027-7864-48ed-b306-122936a4c6e0)
![image](https://github.com/user-attachments/assets/20de74fa-4b1f-421a-b38e-27511783918e)
![image](https://github.com/user-attachments/assets/50f73ffc-8c49-47f0-8e0e-34d4de7f332d)
<img width="309" height="383" alt="image" src="https://github.com/user-attachments/assets/a4b1c8f8-0968-4b6b-9185-316197b39b1f" />

# Analysis of Algorithms Lab:
All the Programs of the 6th Sem Analysis of Algorithms Lab with their output in different steps. This lab provides students with hands-on experience in implementing, analyzing, and comparing fundamental algorithms. It focuses on practical exposure to algorithm design techniques such as divide and conquer, greedy methods, dynamic programming, backtracking, and graph algorithms, enabling students to evaluate time–space complexity and develop efficient algorithmic solutions.

## Introduction to RTU Analysis of Algorithms Lab
The Analysis of Algorithms Lab, as prescribed by Rajasthan Technical University (RTU), is designed to provide students with practical exposure to fundamental algorithmic techniques and their performance evaluation. This lab focuses on implementing classical algorithms, primarily sorting and searching methods, and analyzing their efficiency in terms of time and space complexity.

### Purpose and Objectives
- To understand the design and implementation of various fundamental algorithms.
- To develop skills for analyzing the computational complexity of algorithms.
- To gain hands-on experience in measuring the execution time of algorithms under different input conditions.
- To explore algorithmic problem-solving through coding and experimentation.
- To compare different algorithms solving the same problem to understand their relative efficiencies.

### Core Topics Covered
1. Sorting Algorithms Program
Description: Implements and analyzes various sorting algorithms such as Bubble Sort, Insertion Sort, Merge Sort.
Concepts: Time complexity, space complexity, stability, and efficiency.

2. Backtracking Algorithms Program
Description: Implements and analyzes various backtracking algorithms such as N-Queens.
Concepts: Recursive functions, backtracking, and constraint satisfaction.

3. Graph Algorithms Program
Description: Implements and analyzes various graph algorithms such as Breadth-First Search (BFS), Depth-First Search (DFS), Dijkstra's Algorithm, and Bellman-Ford Algorithm.
Concepts: Graph representation, time complexity, space complexity, and efficiency.

4. NP-Completeness Program
Description: Analyzes the NP-completeness of various problems such as Traveling Salesman, Knapsack, and Vertex Cover.
Concepts: NP-completeness, reducibility, and computational complexity.

5. Dynamic Programming Program
Description: Implements and analyzes various dynamic programming algorithms such as Fibonacci Series, Longest Common Subsequence, and Shortest Path.
Concepts: Overlapping subproblems, optimal substructure, and memoization.

6. Greedy Algorithms Program
Description: Implements and analyzes various greedy algorithms such as Huffman Coding, Activity Selection, and Fractional Knapsack.
Concepts: Optimal substructure, greedy choice, and efficiency.

7. Complexity Analysis Program
Description: Analyzes the time and space complexity of various algorithms using Big-O notation.
Concepts: Asymptotic notation, time complexity, space complexity, and efficiency.

8. Algorithm Design Program
Description: Designs and implements algorithms for various problems such as sorting, searching, and graph traversal.
Concepts: Algorithm design techniques, problem-solving strategies, and efficiency.

9. Data Structures Program
Description: Implements and analyzes various data structures such as arrays, linked lists, stacks, queues, trees, and graphs.
Concepts: Data structure operations, time complexity, space complexity, and efficiency.

10. Searching Algorithms Program
Description: Implements and analyzes various searching algorithms such as Linear Search, Binary Search, and Hashing.
Concepts: Time complexity, space complexity, and efficiency.

### Learning Outcomes
By the end of this lab, students will be able to:
- Write and execute code for various sorting and searching algorithms.
- Analyze and compare the performance of these algorithms using real-time data.
- Understand the importance of algorithmic efficiency in software development.
- Apply algorithmic concepts to solve complex computational problems effectively.

### Lab Methodology
Students will implement algorithms in programming languages such as C, C++, or Java, following the RTU syllabus guidelines. Each experiment involves coding the algorithm, running it on sample or randomly generated data, recording the execution time, and interpreting the results to understand the algorithm's behavior.

### Significance
This lab bridges theoretical concepts with practical application, enabling students to appreciate the impact of algorithm design choices on program performance. It lays a strong foundation for advanced studies in data structures, optimization, and software engineering.

-->These programs and concepts are commonly used in Analysis of Algorithms LAB RTU to help students understand the design, analysis, and implementation of algorithms.

### RTU ML Lab Experiement:

 **1.** Sort a given set of elements using the Quicksort method and determine the time requiredto sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot a graph of     the time taken versus n. The elements can be read from a file or can be generated using the random number generator.

 **2.** Implement a parallelized Merge Sort algorithm to sort a given set of elements and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted  and plot a graph of thetime taken versus n. The elements can be read from a file or can be generated using the random number generator.

 **3.** a. Obtain the Topological ordering of vertices in a given digraph. b. Compute the transitive closure of a given directed graph usingWarshall's algorithm.
 
 **4.** Implement 0/1 Knapsack problem using Dynamic Programming.
 
 **5.** From a given vertex in a weighted connected graph, find shortest paths to other vertices using Dijkstra's algorithm.

 **6.** Find Minimum Cost Spanning Tree of a given undirected graph using Kruskal's algorithm.
 
 **7.** a. Print all the nodes reachable from a given starting node in a digraph using BFS method. 
 
 b. Check whether a given graph is connected or not using DFS method.
 
 **8.** Find Minimum Cost Spanning Tree of a givenundirected graph using Prim’s algorithm.
 
 **9.** Implement All-Pairs Shortest Paths Problem using Floyd's algorithm.

 **10.** Implement N Queen's problem using Back Tracking.

